{"name": "虚拟共用件", "status": "broken", "statusDetails": {"message": "Exception: Could not find '打开' in 'dict_keys(['Shell_SecondaryTrayWnd', 'test_ProcessCenter_MaterialRequisition_Add.pyShell_SecondaryTrayWnd', 'Shell_TrayWnd', '物料申请 - IPM - Google ChromeShell_TrayWnd', 'SunAwtFrame', 'test_ProcessCenter_MaterialRequisition_Add.pySunAwtFrame', 'test_ProcessCenter_MaterialRequisition_Add.py', '物料申请 - IPM - Google Chrome', 'Chrome_WidgetWin_1', '物料申请 - IPM - Google ChromeChrome_WidgetWin_1', 'IPM – ProcessCenter_MaterialRequisition_Add.py PyCharm', 'SunAwtFrame0', 'SunAwtFrame1', 'SunAwtFrame2', 'IPM – ProcessCenter_MaterialRequisition_Add.py PyCharmSunAwtFrame', 'PostmanChrome_WidgetWin_1', 'Chrome_WidgetWin_10', 'Chrome_WidgetWin_11', 'Chrome_WidgetWin_12', 'Postman', 'TranssionerChrome_WidgetWin_0', 'Transsioner', 'Chrome_WidgetWin_0', 'modelins_material @db_ipm_config_uat (IPM) - 表 - Navicat Premium', 'TNavicatMainForm', 'modelins_material @db_ipm_config_uat (IPM) - 表 - Navicat PremiumTNavicatMainForm', 'Chrome_WidgetWin_13', '需求-PI_004 IPM_产品生命周期管理-TAPD平台 - Google Chrome', '需求-PI_004 IPM_产品生命周期管理-TAPD平台 - Google ChromeChrome_WidgetWin_1', 'TfrmUpdate', 'PicPickTfrmUpdate', 'PicPick', 'window-login', 'Chrome_WidgetWin_14', 'window-loginChrome_WidgetWin_1', 'IMWAV', 'SOUIHOST', 'IMWAVSOUIHOST', 'SOUIHOST0', 'SOUIHOST1', 'SOUIHOST2', 'SOUI_DUMMY_WNDSOUIHOST', 'SOUI_DUMMY_WND', '企业微信WeChatLogin', 'WeChatLogin', '企业微信', 'window-loginPerryShadowWnd', 'PerryShadowWnd', 'Microsoft Text Input Application', 'Windows.UI.Core.CoreWindow', 'Microsoft Text Input ApplicationWindows.UI.Core.CoreWindow', 'DummyDWMListenerWindow', 'EdgeUiInputTopWndClass', '物料申请 - IPM - Google ChromeEdgeUiInputTopWndClass', 'SOUI_DUMMY_WNDEdgeUiInputTopWndClass', 'EdgeUiInputTopWndClass0', 'EdgeUiInputTopWndClass1', 'EdgeUiInputTopWndClass2', 'DummyDWMListenerWindow0', 'DummyDWMListenerWindow1', 'DummyDWMListenerWindow2', 'DummyDWMListenerWindow3', 'TBM V4.0版本测试报告 - 副本.docx * - WPS 文字OpusApp', 'OpusApp', 'TBM V4.0版本测试报告 - 副本.docx * - WPS 文字', 'Navicat Premium', 'Navicat PremiumTNavicatMainForm', 'TNavicatMainForm0', 'TNavicatMainForm1', 'TNavicatMainForm2', 'Progman', 'Program Manager', 'Program ManagerProgman'])'", "trace": "self = <pywinauto.application.WindowSpecification object at 0x000001B67EF2D8B0>\ncriteria = [{'backend': 'win32', 'best_match': '打开', 'top_level_only': True}, {'best_match': '文件名(&N):Edit'}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n>           ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\application.py:250: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000001B67EF2D8B0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'backend': 'win32', 'best_match': '打开', 'top_level_only': True}, {'best_match': '文件名(&N):Edit'}],)\nkwargs = {}, start = 567.9067762, time_left = -0.016699600000038117\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n                func_val = func(*args, **kwargs)\n    \n                # if no exception is raised then we are finished\n                break\n    \n            # An exception was raised - so wait and try again\n            except exceptions as e:\n    \n                # find out how much of the time is left\n                time_left = timeout - (timestamp() - start)\n    \n                # if we have to wait some more\n                if time_left > 0:\n                    # wait either the retry_interval or else the amount of\n                    # time until the timeout expires (whichever is less)\n                    time.sleep(min(retry_interval, time_left))\n    \n                else:\n                    # Raise a TimeoutError - and put the original exception\n                    # inside it\n                    err = TimeoutError()\n                    err.original_exception = e\n>                   raise err\nE                   pywinauto.timings.TimeoutError\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\timings.py:458: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\npathDIR = 'D:\\\\IPM\\\\IPM\\\\project\\\\IPM\\\\data'\npath_filename = '手机-虚拟件_123-虚拟共用件.xlsx'\n\n    def Improt_File_n(pathDIR,path_filename):\n        '''\n    \n        :param pathDIR: 导入的文件路径\n        :param path_filename: 文件名\n        :param mumo_lis: 异常备注\n        :return:\n        '''\n        try:\n            # 打开文件选择框\n            # 创建操作桌面的对象\n            app = pywinauto.Desktop()\n            # 获取弹窗的窗口标题\n            dlg = app[\"打开\"]\n            # 打印窗口的所有控件信息\n            # dlg.print_ctrl_ids()\n    \n            # 选择文件地址输入控件\n            dlg[\"Toolbar3\"].click()\n            send_keys(pathDIR)\n            send_keys(\"{VK_RETURN}\")\n            sleep(2)\n    \n            # 输入文件名\n>           dlg[\"文件名(&N):Edit\"].type_keys(path_filename)\n\n..\\page_object\\Center_Component.py:437: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001B67EF2D8B0>\nattr_name = 'type_keys'\n\n    def __getattribute__(self, attr_name):\n        \"\"\"\n        Attribute access for this class\n    \n        If we already have criteria for both dialog and control then\n        resolve the control and return the requested attribute.\n    \n        If we have only criteria for the dialog but the attribute\n        requested is an attribute of DialogWrapper then resolve the\n        dialog and return the requested attribute.\n    \n        Otherwise delegate functionality to :func:`__getitem__` - which\n        sets the appropriate criteria for the control.\n        \"\"\"\n        allow_magic_lookup = object.__getattribute__(self, \"allow_magic_lookup\")  # Beware of recursions here!\n        if not allow_magic_lookup:\n            try:\n                return object.__getattribute__(self, attr_name)\n            except AttributeError:\n                wrapper_object = self.wrapper_object()\n                try:\n                    return getattr(wrapper_object, attr_name)\n                except AttributeError:\n                    message = (\n                        'Attribute \"%s\" exists neither on %s object nor on'\n                        'targeted %s element wrapper (typo? or set allow_magic_lookup to True?)' %\n                        (attr_name, self.__class__, wrapper_object.__class__))\n                    raise AttributeError(message)\n    \n        if attr_name in ['__dict__', '__members__', '__methods__', '__class__', '__name__']:\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in dir(self.__class__):\n            return object.__getattribute__(self, attr_name)\n    \n        if attr_name in self.__dict__:\n            return self.__dict__[attr_name]\n    \n        # if we already have 2 levels of criteria (dlg, control)\n        # this third must be an attribute so resolve and get the\n        # attribute and return it\n        if len(self.criteria) >= 2:  # FIXME - this is surprising\n    \n>           ctrls = self.__resolve_control(self.criteria)\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\application.py:379: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001B67EF2D8B0>\ncriteria = [{'backend': 'win32', 'best_match': '打开', 'top_level_only': True}, {'best_match': '文件名(&N):Edit'}]\ntimeout = 5.0, retry_interval = 0.09\n\n    def __resolve_control(self, criteria, timeout=None, retry_interval=None):\n        \"\"\"\n        Find a control using criteria\n    \n        * **criteria** - a list that contains 1 or 2 dictionaries\n    \n             1st element is search criteria for the dialog\n    \n             2nd element is search criteria for a control of the dialog\n    \n        * **timeout** -  maximum length of time to try to find the controls (default 5)\n        * **retry_interval** - how long to wait between each retry (default .2)\n        \"\"\"\n        if timeout is None:\n            timeout = Timings.window_find_timeout\n        if retry_interval is None:\n            retry_interval = Timings.window_find_retry\n    \n        try:\n            ctrl = wait_until_passes(\n                timeout,\n                retry_interval,\n                self.__get_ctrl,\n                (findwindows.ElementNotFoundError,\n                 findbestmatch.MatchError,\n                 controls.InvalidWindowHandle,\n                 controls.InvalidElement),\n                criteria)\n    \n        except TimeoutError as e:\n>           raise e.original_exception\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\application.py:261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntimeout = 5.0, retry_interval = 0.09\nfunc = <bound method WindowSpecification.__get_ctrl of <pywinauto.application.WindowSpecification object at 0x000001B67EF2D8B0>>\nexceptions = (<class 'pywinauto.findwindows.ElementNotFoundError'>, <class 'pywinauto.findbestmatch.MatchError'>, <class 'pywinauto.controls.hwndwrapper.InvalidWindowHandle'>, <class 'pywinauto.base_wrapper.InvalidElement'>)\nargs = ([{'backend': 'win32', 'best_match': '打开', 'top_level_only': True}, {'best_match': '文件名(&N):Edit'}],)\nkwargs = {}, start = 567.9067762, time_left = -0.016699600000038117\nerr = TimeoutError()\n\n    def wait_until_passes(timeout,\n                          retry_interval,\n                          func,\n                          exceptions=(Exception),\n                          *args, **kwargs):\n        \"\"\"\n        Wait until ``func(*args, **kwargs)`` does not raise one of the exceptions\n    \n        * **timeout**  how long the function will try the function\n        * **retry_interval**  how long to wait between retries\n        * **func** the function that will be executed\n        * **exceptions**  list of exceptions to test against (default: Exception)\n        * **args** optional arguments to be passed to func when called\n        * **kwargs** optional keyword arguments to be passed to func when called\n    \n        Returns the return value of the function\n        If the operation times out then the original exception raised is in\n        the 'original_exception' attribute of the raised exception.\n    \n        e.g. ::\n    \n            try:\n                # wait a maximum of 10.5 seconds for the\n                # window to be found in increments of .5 of a second.\n                # P.int a message and re-raise the original exception if never found.\n                wait_until_passes(10.5, .5, self.Exists, (ElementNotFoundError))\n            except TimeoutError as e:\n                print(\"timed out\")\n                raise e.\n        \"\"\"\n        start = timestamp()\n    \n        # keep trying until the timeout is passed\n        while True:\n            try:\n                # Call the function with any arguments\n>               func_val = func(*args, **kwargs)\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\timings.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pywinauto.application.WindowSpecification object at 0x000001B67EF2D8B0>\ncriteria_ = [{'backend': 'win32', 'best_match': '打开', 'top_level_only': True}, {'best_match': '文件名(&N):Edit'}]\n\n    def __get_ctrl(self, criteria_):\n        \"\"\"Get a control based on the various criteria\"\"\"\n        # make a copy of the criteria\n        criteria = [crit.copy() for crit in criteria_]\n        # find the dialog\n        if 'backend' not in criteria[0]:\n            criteria[0]['backend'] = self.backend.name\n        if self.app is not None:\n            # find_elements(...) accepts only \"process\" argument\n            criteria[0]['process'] = self.app.process\n            del criteria[0]['app']\n>       dialog = self.backend.generic_wrapper_class(findwindows.find_element(**criteria[0]))\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\application.py:203: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nkwargs = {'backend': 'win32', 'best_match': '打开', 'top_level_only': True}\n\n    def find_element(**kwargs):\n        \"\"\"\n        Call find_elements and ensure that only one element is returned\n    \n        Calls find_elements with exactly the same arguments as it is called with\n        so please see :py:func:`find_elements` for the full parameters description.\n        \"\"\"\n>       elements = find_elements(**kwargs)\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\findwindows.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nclass_name = None, class_name_re = None, parent = None, process = None\ntitle = None, title_re = None, top_level_only = True, visible_only = True\nenabled_only = False, best_match = '打开', handle = None, ctrl_index = None\nfound_index = None, predicate_func = None, active_only = False\ncontrol_id = None, control_type = None, auto_id = None, framework_id = None\nbackend = 'win32', depth = None\n\n    def find_elements(class_name=None,\n                      class_name_re=None,\n                      parent=None,\n                      process=None,\n                      title=None,\n                      title_re=None,\n                      top_level_only=True,\n                      visible_only=True,\n                      enabled_only=False,\n                      best_match=None,\n                      handle=None,\n                      ctrl_index=None,\n                      found_index=None,\n                      predicate_func=None,\n                      active_only=False,\n                      control_id=None,\n                      control_type=None,\n                      auto_id=None,\n                      framework_id=None,\n                      backend=None,\n                      depth=None\n                      ):\n        \"\"\"\n        Find elements based on criteria passed in\n    \n        WARNING! Direct usage of this function is not recommended! It's a very low level API.\n        Better use Application and WindowSpecification objects described in the\n        Getting Started Guide.\n    \n        Possible values are:\n    \n        * **class_name**     Elements with this window class\n        * **class_name_re**  Elements whose class matches this regular expression\n        * **parent**         Elements that are children of this\n        * **process**        Elements running in this process\n        * **title**          Elements with this text\n        * **title_re**       Elements whose text matches this regular expression\n        * **top_level_only** Top level elements only (default=**True**)\n        * **visible_only**   Visible elements only (default=**True**)\n        * **enabled_only**   Enabled elements only (default=False)\n        * **best_match**     Elements with a title similar to this\n        * **handle**         The handle of the element to return\n        * **ctrl_index**     The index of the child element to return\n        * **found_index**    The index of the filtered out child element to return\n        * **predicate_func** A user provided hook for a custom element validation\n        * **active_only**    Active elements only (default=False)\n        * **control_id**     Elements with this control id\n        * **control_type**   Elements with this control type (string; for UIAutomation elements)\n        * **auto_id**        Elements with this automation id (for UIAutomation elements)\n        * **framework_id**   Elements with this framework id (for UIAutomation elements)\n        * **backend**        Back-end name to use while searching (default=None means current active backend)\n        \"\"\"\n        if backend is None:\n            backend = registry.active_backend.name\n        backend_obj = registry.backends[backend]\n    \n        # allow a handle to be passed in\n        # if it is present - just return it\n        if handle is not None:\n            return [backend_obj.element_info_class(handle), ]\n    \n        if isinstance(parent, backend_obj.generic_wrapper_class):\n            parent = parent.element_info\n        elif isinstance(parent, six.integer_types):\n            # check if parent is a handle of element (in case of searching native controls)\n            parent = backend_obj.element_info_class(parent)\n    \n        if top_level_only:\n            # find the top level elements\n            element = backend_obj.element_info_class()\n            # vryabov: we don't use title=title below, because it fixes issue 779:\n            # https://github.com/pywinauto/pywinauto/issues/779\n            elements = element.children(process=process,\n                                        class_name=class_name,\n                                        control_type=control_type,\n                                        cache_enable=True)\n    \n            # if we have been given a parent\n            if parent:\n                elements = [elem for elem in elements if elem.parent == parent]\n    \n        # looking for child elements\n        else:\n            # if not given a parent look for all children of the desktop\n            if not parent:\n                parent = backend_obj.element_info_class()\n    \n            # look for ALL children of that parent\n            # vryabov: we don't use title=title below, because it fixes issue 779:\n            # https://github.com/pywinauto/pywinauto/issues/779\n            elements = parent.descendants(class_name=class_name,\n                                          control_type=control_type,\n                                          cache_enable=True,\n                                          depth=depth)\n    \n            # if the ctrl_index has been specified then just return\n            # that control\n            if ctrl_index is not None:\n                return [elements[ctrl_index], ]\n    \n        # early stop\n        if not elements:\n            if found_index is not None:\n                if found_index > 0:\n                    raise ElementNotFoundError(\"found_index is specified as {0}, but no windows found\".format(\n                        found_index))\n            return elements\n    \n        if framework_id is not None and elements:\n            elements = [elem for elem in elements if elem.framework_id == framework_id]\n    \n        if control_id is not None and elements:\n            elements = [elem for elem in elements if elem.control_id == control_id]\n    \n        if active_only:\n            # TODO: re-write to use ElementInfo interface\n            gui_info = win32structures.GUITHREADINFO()\n            gui_info.cbSize = ctypes.sizeof(gui_info)\n    \n            # get all the active elements (not just the specified process)\n            ret = win32functions.GetGUIThreadInfo(0, ctypes.byref(gui_info))\n    \n            if not ret:\n                raise ctypes.WinError()\n    \n            found_active = False\n            for elem in elements:\n                if elem.handle == gui_info.hwndActive:\n                    found_active = True\n                    elements = [elem, ]\n                    break\n            if not found_active:\n                elements = []\n    \n        if class_name is not None:\n            elements = [elem for elem in elements if elem.class_name == class_name]\n    \n        if class_name_re is not None:\n            class_name_regex = re.compile(class_name_re)\n            elements = [elem for elem in elements if class_name_regex.match(elem.class_name)]\n    \n        if process is not None:\n            elements = [elem for elem in elements if elem.process_id == process]\n    \n        if auto_id is not None and elements:\n            elements = [elem for elem in elements if elem.automation_id == auto_id]\n    \n        if title is not None:\n            # TODO: some magic is happenning here\n            if elements:\n                elements[0].rich_text\n            elements = [elem for elem in elements if elem.rich_text == title]\n        elif title_re is not None:\n            title_regex = re.compile(title_re)\n    \n            def _title_match(w):\n                \"\"\"Match a window title to the regexp\"\"\"\n                t = w.rich_text\n                if t is not None:\n                    return title_regex.match(t)\n                return False\n            elements = [elem for elem in elements if _title_match(elem)]\n    \n        if visible_only:\n            elements = [elem for elem in elements if elem.visible]\n    \n        if enabled_only:\n            elements = [elem for elem in elements if elem.enabled]\n    \n        if best_match is not None:\n            # Build a list of wrapped controls.\n            # Speed up the loop by setting up local pointers\n            wrapped_elems = []\n            add_to_wrp_elems = wrapped_elems.append\n            wrp_cls = backend_obj.generic_wrapper_class\n            for elem in elements:\n                try:\n                    add_to_wrp_elems(wrp_cls(elem))\n                except (controls.InvalidWindowHandle,\n                        controls.InvalidElement):\n                    # skip invalid handles - they have dissapeared\n                    # since the list of elements was retrieved\n                    continue\n>           elements = findbestmatch.find_best_control_matches(best_match, wrapped_elems)\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\findwindows.py:305: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nsearch_text = '打开'\ncontrols = [<hwndwrapper.DialogWrapper - '', Shell_SecondaryTrayWnd, 66112>, <hwndwrapper.DialogWrapper - '', Shell_TrayWnd, 6600...sition_Add.py PyCharm', SunAwtFrame, 395838>, <hwndwrapper.DialogWrapper - 'Postman', Chrome_WidgetWin_1, 853040>, ...]\n\n    def find_best_control_matches(search_text, controls):\n        \"\"\"Returns the control that is the the best match to search_text\n    \n        This is slightly differnt from find_best_match in that it builds\n        up the list of text items to search through using information\n        from each control. So for example for there is an OK, Button\n        then the following are all added to the search list:\n        \"OK\", \"Button\", \"OKButton\"\n    \n        But if there is a ListView (which do not have visible 'text')\n        then it will just add \"ListView\".\n        \"\"\"\n        name_control_map = build_unique_dict(controls)\n    \n    \n        #print \">>>>>>>\", repr(name_control_map).decode(\"ascii\", \"ignore\")\n    #    # collect all the possible names for all controls\n    #    # and build a list of them\n    #    for ctrl in controls:\n    #        ctrl_names = get_control_names(ctrl, controls)\n    #\n    #        # for each of the names\n    #        for name in ctrl_names:\n    #            name_control_map[name] = ctrl\n    \n        search_text = six.text_type(search_text)\n    \n        best_ratio, best_texts = name_control_map.find_best_matches(search_text)\n    \n        best_ratio_ci, best_texts_ci = \\\n            name_control_map.find_best_matches(search_text, ignore_case = True)\n    \n        best_ratio_clean, best_texts_clean = \\\n            name_control_map.find_best_matches(search_text, clean = True)\n    \n        best_ratio_clean_ci, best_texts_clean_ci = \\\n            name_control_map.find_best_matches(\n                search_text, clean = True, ignore_case = True)\n    \n    \n        if best_ratio_ci > best_ratio:\n            best_ratio = best_ratio_ci\n            best_texts = best_texts_ci\n    \n        if best_ratio_clean > best_ratio:\n            best_ratio = best_ratio_clean\n            best_texts = best_texts_clean\n    \n        if best_ratio_clean_ci > best_ratio:\n            best_ratio = best_ratio_clean_ci\n            best_texts = best_texts_clean_ci\n    \n        if best_ratio < find_best_control_match_cutoff:\n>           raise MatchError(items = name_control_map.keys(), tofind = search_text)\nE           pywinauto.findbestmatch.MatchError: Could not find '打开' in 'dict_keys(['Shell_SecondaryTrayWnd', 'test_ProcessCenter_MaterialRequisition_Add.pyShell_SecondaryTrayWnd', 'Shell_TrayWnd', '物料申请 - IPM - Google ChromeShell_TrayWnd', 'SunAwtFrame', 'test_ProcessCenter_MaterialRequisition_Add.pySunAwtFrame', 'test_ProcessCenter_MaterialRequisition_Add.py', '物料申请 - IPM - Google Chrome', 'Chrome_WidgetWin_1', '物料申请 - IPM - Google ChromeChrome_WidgetWin_1', 'IPM – ProcessCenter_MaterialRequisition_Add.py PyCharm', 'SunAwtFrame0', 'SunAwtFrame1', 'SunAwtFrame2', 'IPM – ProcessCenter_MaterialRequisition_Add.py PyCharmSunAwtFrame', 'PostmanChrome_WidgetWin_1', 'Chrome_WidgetWin_10', 'Chrome_WidgetWin_11', 'Chrome_WidgetWin_12', 'Postman', 'TranssionerChrome_WidgetWin_0', 'Transsioner', 'Chrome_WidgetWin_0', 'modelins_material @db_ipm_config_uat (IPM) - 表 - Navicat Premium', 'TNavicatMainForm', 'modelins_material @db_ipm_config_uat (IPM) - 表 - Navicat PremiumTNavicatMainForm', 'Chrome_WidgetWin_13', '需求-PI_004 IPM_产品生命周期管理-TAPD平台 - Google Chrome', '需求-PI_004 IPM_产品生命周期管理-TAPD平台 - Google ChromeChrome_WidgetWin_1', 'TfrmUpdate', 'PicPickTfrmUpdate', 'PicPick', 'window-login', 'Chrome_WidgetWin_14', 'window-loginChrome_WidgetWin_1', 'IMWAV', 'SOUIHOST', 'IMWAVSOUIHOST', 'SOUIHOST0', 'SOUIHOST1', 'SOUIHOST2', 'SOUI_DUMMY_WNDSOUIHOST', 'SOUI_DUMMY_WND', '企业微信WeChatLogin', 'WeChatLogin', '企业微信', 'window-loginPerryShadowWnd', 'PerryShadowWnd', 'Microsoft Text Input Application', 'Windows.UI.Core.CoreWindow', 'Microsoft Text Input ApplicationWindows.UI.Core.CoreWindow', 'DummyDWMListenerWindow', 'EdgeUiInputTopWndClass', '物料申请 - IPM - Google ChromeEdgeUiInputTopWndClass', 'SOUI_DUMMY_WNDEdgeUiInputTopWndClass', 'EdgeUiInputTopWndClass0', 'EdgeUiInputTopWndClass1', 'EdgeUiInputTopWndClass2', 'DummyDWMListenerWindow0', 'DummyDWMListenerWindow1', 'DummyDWMListenerWindow2', 'DummyDWMListenerWindow3', 'TBM V4.0版本测试报告 - 副本.docx * - WPS 文字OpusApp', 'OpusApp', 'TBM V4.0版本测试报告 - 副本.docx * - WPS 文字', 'Navicat Premium', 'Navicat PremiumTNavicatMainForm', 'TNavicatMainForm0', 'TNavicatMainForm1', 'TNavicatMainForm2', 'Progman', 'Program Manager', 'Program ManagerProgman'])'\n\nD:\\newpy38\\lib\\site-packages\\pywinauto\\findbestmatch.py:536: MatchError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_ProcessCenter_MaterialRequisition_Add.TestAddMaterial object at 0x000001B67F307370>\ndrivers = <selenium.webdriver.chrome.webdriver.WebDriver (session=\"6e05a4b5c4fddec11378d1ce13cf4cbf\")>\n\n    @allure.story(\"虚拟共用件-正常场景\")\n    @allure.title(\"虚拟共用件\")\n    @allure.description(\"虚拟共用件-物料描述前后端对比”\")\n    @allure.severity(\"trivial\")\n    @pytest.mark.smoke\n    def test_012(self, drivers):\n        Add = MaterialRequisition(drivers)\n        Add.url_MaterialRequisition()\n        sleep(2)\n        Add.information('测试', '手机物料')\n        sleep(1)\n>       Add.import_material('手机', '虚拟件_123\\IPM\\project\\IPM\\data'\n                                  '', '虚拟共用件', '手机-虚拟件_123-虚拟共用件.xlsx')\n\ntest_ProcessCenter_MaterialRequisition_Add.py:193: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\page_object\\ProcessCenter_MaterialRequisition_Add.py:62: in import_material\n    Improt_File_n(DATA, filename)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npathDIR = 'D:\\\\IPM\\\\IPM\\\\project\\\\IPM\\\\data'\npath_filename = '手机-虚拟件_123-虚拟共用件.xlsx'\n\n    def Improt_File_n(pathDIR,path_filename):\n        '''\n    \n        :param pathDIR: 导入的文件路径\n        :param path_filename: 文件名\n        :param mumo_lis: 异常备注\n        :return:\n        '''\n        try:\n            # 打开文件选择框\n            # 创建操作桌面的对象\n            app = pywinauto.Desktop()\n            # 获取弹窗的窗口标题\n            dlg = app[\"打开\"]\n            # 打印窗口的所有控件信息\n            # dlg.print_ctrl_ids()\n    \n            # 选择文件地址输入控件\n            dlg[\"Toolbar3\"].click()\n            send_keys(pathDIR)\n            send_keys(\"{VK_RETURN}\")\n            sleep(2)\n    \n            # 输入文件名\n            dlg[\"文件名(&N):Edit\"].type_keys(path_filename)\n            send_keys(\"{VK_RETURN}\")\n            sleep(2)\n        except Exception as e:\n            print('文件导入失败')\n>           raise Exception(e)\nE           Exception: Could not find '打开' in 'dict_keys(['Shell_SecondaryTrayWnd', 'test_ProcessCenter_MaterialRequisition_Add.pyShell_SecondaryTrayWnd', 'Shell_TrayWnd', '物料申请 - IPM - Google ChromeShell_TrayWnd', 'SunAwtFrame', 'test_ProcessCenter_MaterialRequisition_Add.pySunAwtFrame', 'test_ProcessCenter_MaterialRequisition_Add.py', '物料申请 - IPM - Google Chrome', 'Chrome_WidgetWin_1', '物料申请 - IPM - Google ChromeChrome_WidgetWin_1', 'IPM – ProcessCenter_MaterialRequisition_Add.py PyCharm', 'SunAwtFrame0', 'SunAwtFrame1', 'SunAwtFrame2', 'IPM – ProcessCenter_MaterialRequisition_Add.py PyCharmSunAwtFrame', 'PostmanChrome_WidgetWin_1', 'Chrome_WidgetWin_10', 'Chrome_WidgetWin_11', 'Chrome_WidgetWin_12', 'Postman', 'TranssionerChrome_WidgetWin_0', 'Transsioner', 'Chrome_WidgetWin_0', 'modelins_material @db_ipm_config_uat (IPM) - 表 - Navicat Premium', 'TNavicatMainForm', 'modelins_material @db_ipm_config_uat (IPM) - 表 - Navicat PremiumTNavicatMainForm', 'Chrome_WidgetWin_13', '需求-PI_004 IPM_产品生命周期管理-TAPD平台 - Google Chrome', '需求-PI_004 IPM_产品生命周期管理-TAPD平台 - Google ChromeChrome_WidgetWin_1', 'TfrmUpdate', 'PicPickTfrmUpdate', 'PicPick', 'window-login', 'Chrome_WidgetWin_14', 'window-loginChrome_WidgetWin_1', 'IMWAV', 'SOUIHOST', 'IMWAVSOUIHOST', 'SOUIHOST0', 'SOUIHOST1', 'SOUIHOST2', 'SOUI_DUMMY_WNDSOUIHOST', 'SOUI_DUMMY_WND', '企业微信WeChatLogin', 'WeChatLogin', '企业微信', 'window-loginPerryShadowWnd', 'PerryShadowWnd', 'Microsoft Text Input Application', 'Windows.UI.Core.CoreWindow', 'Microsoft Text Input ApplicationWindows.UI.Core.CoreWindow', 'DummyDWMListenerWindow', 'EdgeUiInputTopWndClass', '物料申请 - IPM - Google ChromeEdgeUiInputTopWndClass', 'SOUI_DUMMY_WNDEdgeUiInputTopWndClass', 'EdgeUiInputTopWndClass0', 'EdgeUiInputTopWndClass1', 'EdgeUiInputTopWndClass2', 'DummyDWMListenerWindow0', 'DummyDWMListenerWindow1', 'DummyDWMListenerWindow2', 'DummyDWMListenerWindow3', 'TBM V4.0版本测试报告 - 副本.docx * - WPS 文字OpusApp', 'OpusApp', 'TBM V4.0版本测试报告 - 副本.docx * - WPS 文字', 'Navicat Premium', 'Navicat PremiumTNavicatMainForm', 'TNavicatMainForm0', 'TNavicatMainForm1', 'TNavicatMainForm2', 'Progman', 'Program Manager', 'Program ManagerProgman'])'\n\n..\\page_object\\Center_Component.py:442: Exception"}, "description": "虚拟共用件-物料描述前后端对比”", "steps": [{"name": "添加失败截图", "status": "passed", "attachments": [{"name": "失败截图", "source": "7939972a-e914-45c7-b845-b9c69264c946-attachment.png", "type": "image/png"}], "start": 1658217444657, "stop": 1658217444921}], "attachments": [{"name": "log", "source": "0a2b93b2-7521-4e80-827b-8262bd7907f4-attachment.txt", "type": "text/plain"}], "start": 1658217343054, "stop": 1658217444390, "uuid": "54a7f3aa-aaed-4301-a6fe-ee30d6d8caa9", "historyId": "f29390d50741cedc73507649f5e33775", "testCaseId": "6fbd2f32a52927813bcb709a05fce739", "fullName": "project.IPM.test_case.test_ProcessCenter_MaterialRequisition_Add.TestAddMaterial#test_012", "labels": [{"name": "feature", "value": "IPM-流程中心-物料申请"}, {"name": "story", "value": "虚拟共用件-正常场景"}, {"name": "severity", "value": "trivial"}, {"name": "tag", "value": "smoke"}, {"name": "parentSuite", "value": "project.IPM.test_case"}, {"name": "suite", "value": "test_ProcessCenter_MaterialRequisition_Add"}, {"name": "subSuite", "value": "TestAddMaterial"}, {"name": "host", "value": "SZLIXS06"}, {"name": "thread", "value": "14300-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "project.IPM.test_case.test_ProcessCenter_MaterialRequisition_Add"}]}